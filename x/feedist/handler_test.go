package feedist

import (
	"context"
	"encoding/binary"
	"testing"

	"github.com/iov-one/weave"
	"github.com/iov-one/weave/app"
	"github.com/iov-one/weave/errors"
	"github.com/iov-one/weave/store"
	"github.com/iov-one/weave/x"
	"github.com/iov-one/weave/x/cash"
)

func TestHandlers(t *testing.T) {
	_, src := helper.MakeKey()

	addr1 := newAddress()
	addr2 := newAddress()

	rt := app.NewRouter()
	auth := helper.CtxAuth("auth")
	cashBucket := cash.NewBucket()
	revenueBucket := NewRevenueBucket()
	ctrl := cash.NewController(cashBucket)
	RegisterRoutes(rt, auth, ctrl)

	qr := weave.NewQueryRouter()
	cash.RegisterQuery(qr)
	RegisterQuery(qr)

	cases := map[string]struct {
		actions  []action
		accounts []account
	}{
		"revenue not found": {
			actions: []action{
				{
					conditions: []weave.Condition{src},
					msg: &DistributeMsg{
						RevenueID: []byte("revenue-with-this-id-does-not-exist"),
					},
					blocksize:      100,
					wantCheckErr:   errors.NotFoundErr,
					wantDeliverErr: errors.NotFoundErr,
				},
			},
		},
		"revenue with afer distributing funds": {
			actions: []action{
				{
					conditions: []weave.Condition{src},
					msg: &DistributeMsg{
						RevenueID: asSeqID(1),
					},
					blocksize:      100,
					wantCheckErr:   nil,
					wantDeliverErr: nil,
				},
			},
		},
	}

	for testName, tc := range cases {
		t.Run(testName, func(t *testing.T) {
			db := store.MemStore()

			_, err := revenueBucket.Create(db, &Revenue{
				Admin: []byte("f427d624ed29c1fae0e2"),
				Recipients: []*Recipient{
					{Weight: 1, Address: addr1},
					{Weight: 2, Address: addr2},
				},
			})
			if err != nil {
				t.Fatalf("cannot create a revenue: %s", err)
			}

			for i, a := range tc.actions {
				cache := db.CacheWrap()
				if _, err := rt.Check(a.ctx(), cache, a.tx()); !errors.Is(err, a.wantCheckErr) {
					t.Logf("want: %+v", a.wantCheckErr)
					t.Logf(" got: %+v", err)
					t.Fatalf("action %d check (%T)", i, a.msg)
				}
				cache.Discard()
				if a.wantCheckErr != nil {
					// Failed checks are causing the message to be ignored.
					continue
				}

				if _, err := rt.Deliver(a.ctx(), db, a.tx()); !errors.Is(err, a.wantDeliverErr) {
					t.Logf("want: %+v", a.wantDeliverErr)
					t.Logf(" got: %+v", err)
					t.Fatalf("action %d delivery (%T)", i, a.msg)
				}
			}
			for i, a := range tc.accounts {
				coins, err := ctrl.Balance(db, a.address)
				if err != nil {
					t.Fatalf("cannot get %+v balance: %s", a, err)
				}
				if !coins.Equals(a.wantCoins) {
					t.Logf("want: %+v", a.wantCoins)
					t.Logf("got: %+v", coins)
					t.Errorf("unexpected coins for %d account (%s)", i, a.address)
				}
			}
		})
	}
}

type account struct {
	address   weave.Address
	wantCoins x.Coins
}

// action represents a single request call that is handled by a handler.
type action struct {
	conditions     []weave.Condition
	msg            weave.Msg
	blocksize      int64
	wantCheckErr   error
	wantDeliverErr error
}

func (a *action) tx() weave.Tx {
	return helper.MockTx(a.msg)
}

func (a *action) ctx() weave.Context {
	ctx := weave.WithHeight(context.Background(), a.blocksize)
	ctx = weave.WithChainID(ctx, "testchain-123")
	return helper.CtxAuth("auth").SetConditions(ctx, a.conditions...)
}

var helper x.TestHelpers

func newAddress() weave.Address {
	_, key := helper.MakeKey()
	return key.Address()
}

// asSeqID returns an ID encoded as if it was generated by the bucket sequence
// call.
func asSeqID(i int64) []byte {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, uint64(i))
	return b
}
